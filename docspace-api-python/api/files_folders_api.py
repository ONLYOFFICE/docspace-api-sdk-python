# (c) Copyright Ascensio System SIA 2009-2025
# 
# This program is a free software product.
# You can redistribute it and/or modify it under the terms
# of the GNU Affero General Public License (AGPL) version 3 as published by the Free Software
# Foundation. In accordance with Section 7(a) of the GNU AGPL its Section 15 shall be amended
# to the effect that Ascensio System SIA expressly excludes the warranty of non-infringement of
# any third-party rights.
# 
# This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For details, see
# the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html
# 
# You can contact Ascensio System SIA at Lubanas st. 125a-25, Riga, Latvia, EU, LV-1021.
# 
# The  interactive user interfaces in modified source and object code versions of the Program must
# display Appropriate Legal Notices, as required under Section 5 of the GNU AGPL version 3.
# 
# Pursuant to Section 7(b) of the License you must retain the original Product logo when
# distributing the program. Pursuant to Section 7(e) we decline to grant you any rights under
# trademark law for use of our trademarks.
# 
# All the Product's GUI elements, including illustrations and icon sets, as well as technical writing
# content are licensed under the terms of the Creative Commons Attribution-ShareAlike 4.0
# International. See the License terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode



import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import Optional, Tuple, Union
from typing_extensions import Annotated
from docspace-api-python.models.api_date_time import ApiDateTime
from docspace-api-python.models.apply_filter_option import ApplyFilterOption
from docspace-api-python.models.check_upload_request import CheckUploadRequest
from docspace-api-python.models.create_folder import CreateFolder
from docspace-api-python.models.delete_folder import DeleteFolder
from docspace-api-python.models.file_entry_array_wrapper import FileEntryArrayWrapper
from docspace-api-python.models.file_integer_wrapper import FileIntegerWrapper
from docspace-api-python.models.file_operation_array_wrapper import FileOperationArrayWrapper
from docspace-api-python.models.file_share_wrapper import FileShareWrapper
from docspace-api-python.models.files_statistics_result_wrapper import FilesStatisticsResultWrapper
from docspace-api-python.models.filter_type import FilterType
from docspace-api-python.models.folder_content_integer_array_wrapper import FolderContentIntegerArrayWrapper
from docspace-api-python.models.folder_content_integer_wrapper import FolderContentIntegerWrapper
from docspace-api-python.models.folder_integer_wrapper import FolderIntegerWrapper
from docspace-api-python.models.forms_item_array_wrapper import FormsItemArrayWrapper
from docspace-api-python.models.history_array_wrapper import HistoryArrayWrapper
from docspace-api-python.models.object_wrapper import ObjectWrapper
from docspace-api-python.models.order_request_dto import OrderRequestDto
from docspace-api-python.models.string_array_wrapper import STRINGArrayWrapper
from docspace-api-python.models.search_area import SearchArea
from docspace-api-python.models.sort_order import SortOrder
from docspace-api-python.models.upload_request_dto import UploadRequestDto

from docspace-api-python.api_client import ApiClient, RequestSerialized
from docspace-api-python.api_response import ApiResponse
from docspace-api-python.rest import RESTResponseType


class FilesFoldersApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def check_upload(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID.")],
        check_upload_request: Annotated[Optional[CheckUploadRequest], Field(description="The request parameters for checking file uploads.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> STRINGArrayWrapper:
        """Check file uploads

        Checks the file uploads to the folder with the ID specified in the request.

        :param folder_id: The folder ID. (required)
        :type folder_id: int
        :param check_upload_request: The request parameters for checking file uploads.
        :type check_upload_request: CheckUploadRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._check_upload_serialize(
            folder_id=folder_id,
            check_upload_request=check_upload_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "STRINGArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def check_upload_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID.")],
        check_upload_request: Annotated[Optional[CheckUploadRequest], Field(description="The request parameters for checking file uploads.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[STRINGArrayWrapper]:
        """Check file uploads

        Checks the file uploads to the folder with the ID specified in the request.

        :param folder_id: The folder ID. (required)
        :type folder_id: int
        :param check_upload_request: The request parameters for checking file uploads.
        :type check_upload_request: CheckUploadRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._check_upload_serialize(
            folder_id=folder_id,
            check_upload_request=check_upload_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "STRINGArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def check_upload_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID.")],
        check_upload_request: Annotated[Optional[CheckUploadRequest], Field(description="The request parameters for checking file uploads.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Check file uploads

        Checks the file uploads to the folder with the ID specified in the request.

        :param folder_id: The folder ID. (required)
        :type folder_id: int
        :param check_upload_request: The request parameters for checking file uploads.
        :type check_upload_request: CheckUploadRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._check_upload_serialize(
            folder_id=folder_id,
            check_upload_request=check_upload_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "STRINGArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _check_upload_serialize(
        self,
        folder_id,
        check_upload_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if check_upload_request is not None:
            _body_params = check_upload_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.0/files/{folderId}/upload/check',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_folder(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID for the folder creation.")],
        create_folder: Annotated[Optional[CreateFolder], Field(description="The parameters for creating a folder.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FolderIntegerWrapper:
        """Create a folder

        Creates a new folder with the title specified in the request. The parent folder ID can be also specified.

        :param folder_id: The folder ID for the folder creation. (required)
        :type folder_id: int
        :param create_folder: The parameters for creating a folder.
        :type create_folder: CreateFolder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_folder_serialize(
            folder_id=folder_id,
            create_folder=create_folder,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_folder_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID for the folder creation.")],
        create_folder: Annotated[Optional[CreateFolder], Field(description="The parameters for creating a folder.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FolderIntegerWrapper]:
        """Create a folder

        Creates a new folder with the title specified in the request. The parent folder ID can be also specified.

        :param folder_id: The folder ID for the folder creation. (required)
        :type folder_id: int
        :param create_folder: The parameters for creating a folder.
        :type create_folder: CreateFolder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_folder_serialize(
            folder_id=folder_id,
            create_folder=create_folder,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_folder_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID for the folder creation.")],
        create_folder: Annotated[Optional[CreateFolder], Field(description="The parameters for creating a folder.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a folder

        Creates a new folder with the title specified in the request. The parent folder ID can be also specified.

        :param folder_id: The folder ID for the folder creation. (required)
        :type folder_id: int
        :param create_folder: The parameters for creating a folder.
        :type create_folder: CreateFolder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_folder_serialize(
            folder_id=folder_id,
            create_folder=create_folder,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_folder_serialize(
        self,
        folder_id,
        create_folder,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_folder is not None:
            _body_params = create_folder


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.0/files/folder/{folderId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_folder(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID to delete.")],
        delete_folder: Annotated[Optional[DeleteFolder], Field(description="The parameters for deleting a folder.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileOperationArrayWrapper:
        """Delete a folder

        Deletes a folder with the ID specified in the request.

        :param folder_id: The folder ID to delete. (required)
        :type folder_id: int
        :param delete_folder: The parameters for deleting a folder.
        :type delete_folder: DeleteFolder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_folder_serialize(
            folder_id=folder_id,
            delete_folder=delete_folder,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileOperationArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_folder_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID to delete.")],
        delete_folder: Annotated[Optional[DeleteFolder], Field(description="The parameters for deleting a folder.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileOperationArrayWrapper]:
        """Delete a folder

        Deletes a folder with the ID specified in the request.

        :param folder_id: The folder ID to delete. (required)
        :type folder_id: int
        :param delete_folder: The parameters for deleting a folder.
        :type delete_folder: DeleteFolder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_folder_serialize(
            folder_id=folder_id,
            delete_folder=delete_folder,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileOperationArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_folder_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID to delete.")],
        delete_folder: Annotated[Optional[DeleteFolder], Field(description="The parameters for deleting a folder.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a folder

        Deletes a folder with the ID specified in the request.

        :param folder_id: The folder ID to delete. (required)
        :type folder_id: int
        :param delete_folder: The parameters for deleting a folder.
        :type delete_folder: DeleteFolder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_folder_serialize(
            folder_id=folder_id,
            delete_folder=delete_folder,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileOperationArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_folder_serialize(
        self,
        folder_id,
        delete_folder,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if delete_folder is not None:
            _body_params = delete_folder


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.0/files/folder/{folderId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_files_used_space(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FilesStatisticsResultWrapper:
        """Get used space of files

        Returns the used space of files in the root folders.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_files_used_space_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesStatisticsResultWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_files_used_space_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FilesStatisticsResultWrapper]:
        """Get used space of files

        Returns the used space of files in the root folders.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_files_used_space_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesStatisticsResultWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_files_used_space_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get used space of files

        Returns the used space of files in the root folders.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_files_used_space_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilesStatisticsResultWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_files_used_space_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/filesusedspace',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_folder(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FormsItemArrayWrapper:
        """Get folder form filter

        Returns the form filter of a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormsItemArrayWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_folder_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FormsItemArrayWrapper]:
        """Get folder form filter

        Returns the form filter of a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormsItemArrayWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_folder_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get folder form filter

        Returns the form filter of a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FormsItemArrayWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_folder_serialize(
        self,
        folder_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/{folderId}/formfilter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_folder_by_folder_id(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID of the request.")],
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        room_id: Annotated[Optional[StrictInt], Field(description="The room ID.")] = None,
        exclude_subject: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude search by user or group ID.")] = None,
        apply_filter_option: Annotated[Optional[ApplyFilterOption], Field(description="Specifies whether to return only files, only folders or all elements from the specified folder.")] = None,
        extension: Annotated[Optional[StrictStr], Field(description="Specifies whether to search for the specific file extension.")] = None,
        search_area: Annotated[Optional[SearchArea], Field(description="The search area.")] = None,
        forms_item_key: Annotated[Optional[StrictStr], Field(description="The forms item key.")] = None,
        forms_item_type: Annotated[Optional[StrictStr], Field(description="The forms item type.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to retrieve in a paginated request.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the property used for sorting the folder request results.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text value used as a filter parameter for folder content queries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FolderContentIntegerWrapper:
        """Get a folder by ID

        Returns the detailed list of files and folders located in the folder with the ID specified in the request.

        :param folder_id: The folder ID of the request. (required)
        :type folder_id: int
        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param room_id: The room ID.
        :type room_id: int
        :param exclude_subject: Specifies whether to exclude search by user or group ID.
        :type exclude_subject: bool
        :param apply_filter_option: Specifies whether to return only files, only folders or all elements from the specified folder.
        :type apply_filter_option: ApplyFilterOption
        :param extension: Specifies whether to search for the specific file extension.
        :type extension: str
        :param search_area: The search area.
        :type search_area: SearchArea
        :param forms_item_key: The forms item key.
        :type forms_item_key: str
        :param forms_item_type: The forms item type.
        :type forms_item_type: str
        :param count: The maximum number of items to retrieve in the request.
        :type count: int
        :param start_index: The zero-based index of the first item to retrieve in a paginated request.
        :type start_index: int
        :param sort_by: Specifies the property used for sorting the folder request results.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text value used as a filter parameter for folder content queries.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_by_folder_id_serialize(
            folder_id=folder_id,
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            room_id=room_id,
            exclude_subject=exclude_subject,
            apply_filter_option=apply_filter_option,
            extension=extension,
            search_area=search_area,
            forms_item_key=forms_item_key,
            forms_item_type=forms_item_type,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_folder_by_folder_id_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID of the request.")],
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        room_id: Annotated[Optional[StrictInt], Field(description="The room ID.")] = None,
        exclude_subject: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude search by user or group ID.")] = None,
        apply_filter_option: Annotated[Optional[ApplyFilterOption], Field(description="Specifies whether to return only files, only folders or all elements from the specified folder.")] = None,
        extension: Annotated[Optional[StrictStr], Field(description="Specifies whether to search for the specific file extension.")] = None,
        search_area: Annotated[Optional[SearchArea], Field(description="The search area.")] = None,
        forms_item_key: Annotated[Optional[StrictStr], Field(description="The forms item key.")] = None,
        forms_item_type: Annotated[Optional[StrictStr], Field(description="The forms item type.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to retrieve in a paginated request.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the property used for sorting the folder request results.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text value used as a filter parameter for folder content queries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FolderContentIntegerWrapper]:
        """Get a folder by ID

        Returns the detailed list of files and folders located in the folder with the ID specified in the request.

        :param folder_id: The folder ID of the request. (required)
        :type folder_id: int
        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param room_id: The room ID.
        :type room_id: int
        :param exclude_subject: Specifies whether to exclude search by user or group ID.
        :type exclude_subject: bool
        :param apply_filter_option: Specifies whether to return only files, only folders or all elements from the specified folder.
        :type apply_filter_option: ApplyFilterOption
        :param extension: Specifies whether to search for the specific file extension.
        :type extension: str
        :param search_area: The search area.
        :type search_area: SearchArea
        :param forms_item_key: The forms item key.
        :type forms_item_key: str
        :param forms_item_type: The forms item type.
        :type forms_item_type: str
        :param count: The maximum number of items to retrieve in the request.
        :type count: int
        :param start_index: The zero-based index of the first item to retrieve in a paginated request.
        :type start_index: int
        :param sort_by: Specifies the property used for sorting the folder request results.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text value used as a filter parameter for folder content queries.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_by_folder_id_serialize(
            folder_id=folder_id,
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            room_id=room_id,
            exclude_subject=exclude_subject,
            apply_filter_option=apply_filter_option,
            extension=extension,
            search_area=search_area,
            forms_item_key=forms_item_key,
            forms_item_type=forms_item_type,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_folder_by_folder_id_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID of the request.")],
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        room_id: Annotated[Optional[StrictInt], Field(description="The room ID.")] = None,
        exclude_subject: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude search by user or group ID.")] = None,
        apply_filter_option: Annotated[Optional[ApplyFilterOption], Field(description="Specifies whether to return only files, only folders or all elements from the specified folder.")] = None,
        extension: Annotated[Optional[StrictStr], Field(description="Specifies whether to search for the specific file extension.")] = None,
        search_area: Annotated[Optional[SearchArea], Field(description="The search area.")] = None,
        forms_item_key: Annotated[Optional[StrictStr], Field(description="The forms item key.")] = None,
        forms_item_type: Annotated[Optional[StrictStr], Field(description="The forms item type.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to retrieve in a paginated request.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the property used for sorting the folder request results.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text value used as a filter parameter for folder content queries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a folder by ID

        Returns the detailed list of files and folders located in the folder with the ID specified in the request.

        :param folder_id: The folder ID of the request. (required)
        :type folder_id: int
        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param room_id: The room ID.
        :type room_id: int
        :param exclude_subject: Specifies whether to exclude search by user or group ID.
        :type exclude_subject: bool
        :param apply_filter_option: Specifies whether to return only files, only folders or all elements from the specified folder.
        :type apply_filter_option: ApplyFilterOption
        :param extension: Specifies whether to search for the specific file extension.
        :type extension: str
        :param search_area: The search area.
        :type search_area: SearchArea
        :param forms_item_key: The forms item key.
        :type forms_item_key: str
        :param forms_item_type: The forms item type.
        :type forms_item_type: str
        :param count: The maximum number of items to retrieve in the request.
        :type count: int
        :param start_index: The zero-based index of the first item to retrieve in a paginated request.
        :type start_index: int
        :param sort_by: Specifies the property used for sorting the folder request results.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text value used as a filter parameter for folder content queries.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_by_folder_id_serialize(
            folder_id=folder_id,
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            room_id=room_id,
            exclude_subject=exclude_subject,
            apply_filter_option=apply_filter_option,
            extension=extension,
            search_area=search_area,
            forms_item_key=forms_item_key,
            forms_item_type=forms_item_type,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_folder_by_folder_id_serialize(
        self,
        folder_id,
        user_id_or_group_id,
        filter_type,
        room_id,
        exclude_subject,
        apply_filter_option,
        extension,
        search_area,
        forms_item_key,
        forms_item_type,
        count,
        start_index,
        sort_by,
        sort_order,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        if user_id_or_group_id is not None:
            
            _query_params.append(('userIdOrGroupId', user_id_or_group_id))
            
        if filter_type is not None:
            
            _query_params.append(('filterType', filter_type.value))
            
        if room_id is not None:
            
            _query_params.append(('roomId', room_id))
            
        if exclude_subject is not None:
            
            _query_params.append(('excludeSubject', exclude_subject))
            
        if apply_filter_option is not None:
            
            _query_params.append(('applyFilterOption', apply_filter_option.value))
            
        if extension is not None:
            
            _query_params.append(('extension', extension))
            
        if search_area is not None:
            
            _query_params.append(('searchArea', search_area.value))
            
        if forms_item_key is not None:
            
            _query_params.append(('formsItemKey', forms_item_key))
            
        if forms_item_type is not None:
            
            _query_params.append(('formsItemType', forms_item_type))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order.value))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/{folderId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_folder_history(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID of the history request.")],
        from_date: Annotated[Optional[ApiDateTime], Field(description="The start date of the history request.")] = None,
        to_date: Annotated[Optional[ApiDateTime], Field(description="The end date of the history request.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of records to retrieve for the folder history.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index from which the history records are retrieved in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HistoryArrayWrapper:
        """Get folder history

        Returns the activity history of a folder with a specified identifier.

        :param folder_id: The folder ID of the history request. (required)
        :type folder_id: int
        :param from_date: The start date of the history request.
        :type from_date: ApiDateTime
        :param to_date: The end date of the history request.
        :type to_date: ApiDateTime
        :param count: The number of records to retrieve for the folder history.
        :type count: int
        :param start_index: The starting index from which the history records are retrieved in the request.
        :type start_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_history_serialize(
            folder_id=folder_id,
            from_date=from_date,
            to_date=to_date,
            count=count,
            start_index=start_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HistoryArrayWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_folder_history_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID of the history request.")],
        from_date: Annotated[Optional[ApiDateTime], Field(description="The start date of the history request.")] = None,
        to_date: Annotated[Optional[ApiDateTime], Field(description="The end date of the history request.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of records to retrieve for the folder history.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index from which the history records are retrieved in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HistoryArrayWrapper]:
        """Get folder history

        Returns the activity history of a folder with a specified identifier.

        :param folder_id: The folder ID of the history request. (required)
        :type folder_id: int
        :param from_date: The start date of the history request.
        :type from_date: ApiDateTime
        :param to_date: The end date of the history request.
        :type to_date: ApiDateTime
        :param count: The number of records to retrieve for the folder history.
        :type count: int
        :param start_index: The starting index from which the history records are retrieved in the request.
        :type start_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_history_serialize(
            folder_id=folder_id,
            from_date=from_date,
            to_date=to_date,
            count=count,
            start_index=start_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HistoryArrayWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_folder_history_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID of the history request.")],
        from_date: Annotated[Optional[ApiDateTime], Field(description="The start date of the history request.")] = None,
        to_date: Annotated[Optional[ApiDateTime], Field(description="The end date of the history request.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The number of records to retrieve for the folder history.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting index from which the history records are retrieved in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get folder history

        Returns the activity history of a folder with a specified identifier.

        :param folder_id: The folder ID of the history request. (required)
        :type folder_id: int
        :param from_date: The start date of the history request.
        :type from_date: ApiDateTime
        :param to_date: The end date of the history request.
        :type to_date: ApiDateTime
        :param count: The number of records to retrieve for the folder history.
        :type count: int
        :param start_index: The starting index from which the history records are retrieved in the request.
        :type start_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_history_serialize(
            folder_id=folder_id,
            from_date=from_date,
            to_date=to_date,
            count=count,
            start_index=start_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HistoryArrayWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_folder_history_serialize(
        self,
        folder_id,
        from_date,
        to_date,
        count,
        start_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        if to_date is not None:
            
            _query_params.append(('toDate', to_date))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/folder/{folderId}/log',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_folder_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FolderIntegerWrapper:
        """Get folder information

        Returns the detailed information about a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_info_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_folder_info_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FolderIntegerWrapper]:
        """Get folder information

        Returns the detailed information about a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_info_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_folder_info_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get folder information

        Returns the detailed information about a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_info_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_folder_info_serialize(
        self,
        folder_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/folder/{folderId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_folder_path(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileEntryArrayWrapper:
        """Get the folder path

        Returns a path to the folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_path_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntryArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_folder_path_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileEntryArrayWrapper]:
        """Get the folder path

        Returns a path to the folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_path_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntryArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_folder_path_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the folder path

        Returns a path to the folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_path_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntryArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_folder_path_serialize(
        self,
        folder_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/folder/{folderId}/path',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_folder_primary_external_link(
        self,
        id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileShareWrapper:
        """Get primary external link

        Returns the primary external link by the identifier specified in the request.

        :param id: The request folder ID. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_primary_external_link_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileShareWrapper",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_folder_primary_external_link_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileShareWrapper]:
        """Get primary external link

        Returns the primary external link by the identifier specified in the request.

        :param id: The request folder ID. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_primary_external_link_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileShareWrapper",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_folder_primary_external_link_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get primary external link

        Returns the primary external link by the identifier specified in the request.

        :param id: The request folder ID. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folder_primary_external_link_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileShareWrapper",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_folder_primary_external_link_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/folder/{id}/link',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_folders(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileEntryArrayWrapper:
        """Get subfolders

        Returns a list of all the subfolders from a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folders_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntryArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_folders_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileEntryArrayWrapper]:
        """Get subfolders

        Returns a list of all the subfolders from a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folders_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntryArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_folders_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get subfolders

        Returns a list of all the subfolders from a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_folders_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntryArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_folders_serialize(
        self,
        folder_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/{folderId}/subfolders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_my_folder(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        apply_filter_option: Annotated[Optional[ApplyFilterOption], Field(description="Specifies whether to return only files, only folders or all elements.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting position of the items to be retrieved.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The property used to specify the sorting criteria for folder contents.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used for filtering or searching folder contents.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FolderContentIntegerWrapper:
        """Get the \"My documents\" section

        Returns the detailed list of files and folders located in the \"My documents\" section.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param apply_filter_option: Specifies whether to return only files, only folders or all elements.
        :type apply_filter_option: ApplyFilterOption
        :param count: The maximum number of items to retrieve in the response.
        :type count: int
        :param start_index: The starting position of the items to be retrieved.
        :type start_index: int
        :param sort_by: The property used to specify the sorting criteria for folder contents.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used for filtering or searching folder contents.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_folder_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            apply_filter_option=apply_filter_option,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_my_folder_with_http_info(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        apply_filter_option: Annotated[Optional[ApplyFilterOption], Field(description="Specifies whether to return only files, only folders or all elements.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting position of the items to be retrieved.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The property used to specify the sorting criteria for folder contents.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used for filtering or searching folder contents.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FolderContentIntegerWrapper]:
        """Get the \"My documents\" section

        Returns the detailed list of files and folders located in the \"My documents\" section.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param apply_filter_option: Specifies whether to return only files, only folders or all elements.
        :type apply_filter_option: ApplyFilterOption
        :param count: The maximum number of items to retrieve in the response.
        :type count: int
        :param start_index: The starting position of the items to be retrieved.
        :type start_index: int
        :param sort_by: The property used to specify the sorting criteria for folder contents.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used for filtering or searching folder contents.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_folder_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            apply_filter_option=apply_filter_option,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_my_folder_without_preload_content(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        apply_filter_option: Annotated[Optional[ApplyFilterOption], Field(description="Specifies whether to return only files, only folders or all elements.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting position of the items to be retrieved.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The property used to specify the sorting criteria for folder contents.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used for filtering or searching folder contents.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the \"My documents\" section

        Returns the detailed list of files and folders located in the \"My documents\" section.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param apply_filter_option: Specifies whether to return only files, only folders or all elements.
        :type apply_filter_option: ApplyFilterOption
        :param count: The maximum number of items to retrieve in the response.
        :type count: int
        :param start_index: The starting position of the items to be retrieved.
        :type start_index: int
        :param sort_by: The property used to specify the sorting criteria for folder contents.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used for filtering or searching folder contents.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_my_folder_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            apply_filter_option=apply_filter_option,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_my_folder_serialize(
        self,
        user_id_or_group_id,
        filter_type,
        apply_filter_option,
        count,
        start_index,
        sort_by,
        sort_order,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_id_or_group_id is not None:
            
            _query_params.append(('userIdOrGroupId', user_id_or_group_id))
            
        if filter_type is not None:
            
            _query_params.append(('filterType', filter_type.value))
            
        if apply_filter_option is not None:
            
            _query_params.append(('applyFilterOption', apply_filter_option.value))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order.value))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/@my',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_new_folder_items(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileEntryArrayWrapper:
        """Get new folder items

        Returns a list of all the new items from a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_new_folder_items_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntryArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_new_folder_items_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileEntryArrayWrapper]:
        """Get new folder items

        Returns a list of all the new items from a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_new_folder_items_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntryArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_new_folder_items_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The request folder ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get new folder items

        Returns a list of all the new items from a folder with the ID specified in the request.

        :param folder_id: The request folder ID. (required)
        :type folder_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_new_folder_items_serialize(
            folder_id=folder_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileEntryArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_new_folder_items_serialize(
        self,
        folder_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/{folderId}/news',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_privacy_folder(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to retrieve in a paginated list.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the field by which the folder content should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used as a filter or search criterion for folder content queries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FolderContentIntegerWrapper:
        """Get the \"Private Room\" section

        Returns the detailed list of files and folders located in the \"Private Room\" section.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param count: The maximum number of items to retrieve in the request.
        :type count: int
        :param start_index: The zero-based index of the first item to retrieve in a paginated list.
        :type start_index: int
        :param sort_by: Specifies the field by which the folder content should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used as a filter or search criterion for folder content queries.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_privacy_folder_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_privacy_folder_with_http_info(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to retrieve in a paginated list.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the field by which the folder content should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used as a filter or search criterion for folder content queries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FolderContentIntegerWrapper]:
        """Get the \"Private Room\" section

        Returns the detailed list of files and folders located in the \"Private Room\" section.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param count: The maximum number of items to retrieve in the request.
        :type count: int
        :param start_index: The zero-based index of the first item to retrieve in a paginated list.
        :type start_index: int
        :param sort_by: Specifies the field by which the folder content should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used as a filter or search criterion for folder content queries.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_privacy_folder_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_privacy_folder_without_preload_content(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the request.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The zero-based index of the first item to retrieve in a paginated list.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the field by which the folder content should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used as a filter or search criterion for folder content queries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the \"Private Room\" section

        Returns the detailed list of files and folders located in the \"Private Room\" section.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param count: The maximum number of items to retrieve in the request.
        :type count: int
        :param start_index: The zero-based index of the first item to retrieve in a paginated list.
        :type start_index: int
        :param sort_by: Specifies the field by which the folder content should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used as a filter or search criterion for folder content queries.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_privacy_folder_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_privacy_folder_serialize(
        self,
        user_id_or_group_id,
        filter_type,
        count,
        start_index,
        sort_by,
        sort_order,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_id_or_group_id is not None:
            
            _query_params.append(('userIdOrGroupId', user_id_or_group_id))
            
        if filter_type is not None:
            
            _query_params.append(('filterType', filter_type.value))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order.value))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/@privacy',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_root_folders(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        without_trash: Annotated[Optional[StrictBool], Field(description="Specifies whether to return the \"Trash\" section or not.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting position of the items to be retrieved.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the field by which the folder content should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used as a filter for searching or retrieving folder contents.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FolderContentIntegerArrayWrapper:
        """Get filtered sections

        Returns all the sections matching the parameters specified in the request.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param without_trash: Specifies whether to return the \"Trash\" section or not.
        :type without_trash: bool
        :param count: The maximum number of items to retrieve in the response.
        :type count: int
        :param start_index: The starting position of the items to be retrieved.
        :type start_index: int
        :param sort_by: Specifies the field by which the folder content should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used as a filter for searching or retrieving folder contents.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_root_folders_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            without_trash=without_trash,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerArrayWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_root_folders_with_http_info(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        without_trash: Annotated[Optional[StrictBool], Field(description="Specifies whether to return the \"Trash\" section or not.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting position of the items to be retrieved.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the field by which the folder content should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used as a filter for searching or retrieving folder contents.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FolderContentIntegerArrayWrapper]:
        """Get filtered sections

        Returns all the sections matching the parameters specified in the request.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param without_trash: Specifies whether to return the \"Trash\" section or not.
        :type without_trash: bool
        :param count: The maximum number of items to retrieve in the response.
        :type count: int
        :param start_index: The starting position of the items to be retrieved.
        :type start_index: int
        :param sort_by: Specifies the field by which the folder content should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used as a filter for searching or retrieving folder contents.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_root_folders_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            without_trash=without_trash,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerArrayWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_root_folders_without_preload_content(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        without_trash: Annotated[Optional[StrictBool], Field(description="Specifies whether to return the \"Trash\" section or not.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting position of the items to be retrieved.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specifies the field by which the folder content should be sorted.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used as a filter for searching or retrieving folder contents.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get filtered sections

        Returns all the sections matching the parameters specified in the request.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param without_trash: Specifies whether to return the \"Trash\" section or not.
        :type without_trash: bool
        :param count: The maximum number of items to retrieve in the response.
        :type count: int
        :param start_index: The starting position of the items to be retrieved.
        :type start_index: int
        :param sort_by: Specifies the field by which the folder content should be sorted.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used as a filter for searching or retrieving folder contents.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_root_folders_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            without_trash=without_trash,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerArrayWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_root_folders_serialize(
        self,
        user_id_or_group_id,
        filter_type,
        without_trash,
        count,
        start_index,
        sort_by,
        sort_order,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_id_or_group_id is not None:
            
            _query_params.append(('userIdOrGroupId', user_id_or_group_id))
            
        if filter_type is not None:
            
            _query_params.append(('filterType', filter_type.value))
            
        if without_trash is not None:
            
            _query_params.append(('withoutTrash', without_trash))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order.value))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/@root',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_trash_folder(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        apply_filter_option: Annotated[Optional[ApplyFilterOption], Field(description="Specifies whether to return only files, only folders or all elements.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting position of the items to be retrieved.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The property used to specify the sorting criteria for folder contents.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used for filtering or searching folder contents.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FolderContentIntegerWrapper:
        """Get the \"Trash\" section

        Returns the detailed list of files and folders located in the \"Trash\" section.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param apply_filter_option: Specifies whether to return only files, only folders or all elements.
        :type apply_filter_option: ApplyFilterOption
        :param count: The maximum number of items to retrieve in the response.
        :type count: int
        :param start_index: The starting position of the items to be retrieved.
        :type start_index: int
        :param sort_by: The property used to specify the sorting criteria for folder contents.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used for filtering or searching folder contents.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trash_folder_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            apply_filter_option=apply_filter_option,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_trash_folder_with_http_info(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        apply_filter_option: Annotated[Optional[ApplyFilterOption], Field(description="Specifies whether to return only files, only folders or all elements.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting position of the items to be retrieved.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The property used to specify the sorting criteria for folder contents.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used for filtering or searching folder contents.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FolderContentIntegerWrapper]:
        """Get the \"Trash\" section

        Returns the detailed list of files and folders located in the \"Trash\" section.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param apply_filter_option: Specifies whether to return only files, only folders or all elements.
        :type apply_filter_option: ApplyFilterOption
        :param count: The maximum number of items to retrieve in the response.
        :type count: int
        :param start_index: The starting position of the items to be retrieved.
        :type start_index: int
        :param sort_by: The property used to specify the sorting criteria for folder contents.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used for filtering or searching folder contents.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trash_folder_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            apply_filter_option=apply_filter_option,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_trash_folder_without_preload_content(
        self,
        user_id_or_group_id: Annotated[Optional[StrictStr], Field(description="The user or group ID.")] = None,
        filter_type: Annotated[Optional[FilterType], Field(description="The filter type.")] = None,
        apply_filter_option: Annotated[Optional[ApplyFilterOption], Field(description="Specifies whether to return only files, only folders or all elements.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to retrieve in the response.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="The starting position of the items to be retrieved.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="The property used to specify the sorting criteria for folder contents.")] = None,
        sort_order: Annotated[Optional[SortOrder], Field(description="The order in which the results are sorted.")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="The text used for filtering or searching folder contents.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the \"Trash\" section

        Returns the detailed list of files and folders located in the \"Trash\" section.

        :param user_id_or_group_id: The user or group ID.
        :type user_id_or_group_id: str
        :param filter_type: The filter type.
        :type filter_type: FilterType
        :param apply_filter_option: Specifies whether to return only files, only folders or all elements.
        :type apply_filter_option: ApplyFilterOption
        :param count: The maximum number of items to retrieve in the response.
        :type count: int
        :param start_index: The starting position of the items to be retrieved.
        :type start_index: int
        :param sort_by: The property used to specify the sorting criteria for folder contents.
        :type sort_by: str
        :param sort_order: The order in which the results are sorted.
        :type sort_order: SortOrder
        :param filter_value: The text used for filtering or searching folder contents.
        :type filter_value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_trash_folder_serialize(
            user_id_or_group_id=user_id_or_group_id,
            filter_type=filter_type,
            apply_filter_option=apply_filter_option,
            count=count,
            start_index=start_index,
            sort_by=sort_by,
            sort_order=sort_order,
            filter_value=filter_value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderContentIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_trash_folder_serialize(
        self,
        user_id_or_group_id,
        filter_type,
        apply_filter_option,
        count,
        start_index,
        sort_by,
        sort_order,
        filter_value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_id_or_group_id is not None:
            
            _query_params.append(('userIdOrGroupId', user_id_or_group_id))
            
        if filter_type is not None:
            
            _query_params.append(('filterType', filter_type.value))
            
        if apply_filter_option is not None:
            
            _query_params.append(('applyFilterOption', apply_filter_option.value))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order.value))
            
        if filter_value is not None:
            
            _query_params.append(('filterValue', filter_value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/files/@trash',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def insert_file(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID for inserting a file.")],
        insert_file_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The file to be inserted.")] = None,
        insert_file_title: Annotated[Optional[StrictStr], Field(description="The file title to be inserted.")] = None,
        insert_file_create_new_if_exist: Annotated[Optional[StrictBool], Field(description="Specifies whether to create a new file if it already exists or not.")] = None,
        insert_file_keep_convert_status: Annotated[Optional[StrictBool], Field(description="Specifies whether to keep the file converting status or not.")] = None,
        insert_file_stream_can_read: Optional[StrictBool] = None,
        insert_file_stream_can_write: Optional[StrictBool] = None,
        insert_file_stream_can_seek: Optional[StrictBool] = None,
        insert_file_stream_can_timeout: Optional[StrictBool] = None,
        insert_file_stream_length: Optional[StrictInt] = None,
        insert_file_stream_position: Optional[StrictInt] = None,
        insert_file_stream_read_timeout: Optional[StrictInt] = None,
        insert_file_stream_write_timeout: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileIntegerWrapper:
        """Insert a file

        Inserts a file specified in the request to the selected folder by single file uploading.

        :param folder_id: The folder ID for inserting a file. (required)
        :type folder_id: int
        :param insert_file_file: The file to be inserted.
        :type insert_file_file: bytearray
        :param insert_file_title: The file title to be inserted.
        :type insert_file_title: str
        :param insert_file_create_new_if_exist: Specifies whether to create a new file if it already exists or not.
        :type insert_file_create_new_if_exist: bool
        :param insert_file_keep_convert_status: Specifies whether to keep the file converting status or not.
        :type insert_file_keep_convert_status: bool
        :param insert_file_stream_can_read:
        :type insert_file_stream_can_read: bool
        :param insert_file_stream_can_write:
        :type insert_file_stream_can_write: bool
        :param insert_file_stream_can_seek:
        :type insert_file_stream_can_seek: bool
        :param insert_file_stream_can_timeout:
        :type insert_file_stream_can_timeout: bool
        :param insert_file_stream_length:
        :type insert_file_stream_length: int
        :param insert_file_stream_position:
        :type insert_file_stream_position: int
        :param insert_file_stream_read_timeout:
        :type insert_file_stream_read_timeout: int
        :param insert_file_stream_write_timeout:
        :type insert_file_stream_write_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._insert_file_serialize(
            folder_id=folder_id,
            insert_file_file=insert_file_file,
            insert_file_title=insert_file_title,
            insert_file_create_new_if_exist=insert_file_create_new_if_exist,
            insert_file_keep_convert_status=insert_file_keep_convert_status,
            insert_file_stream_can_read=insert_file_stream_can_read,
            insert_file_stream_can_write=insert_file_stream_can_write,
            insert_file_stream_can_seek=insert_file_stream_can_seek,
            insert_file_stream_can_timeout=insert_file_stream_can_timeout,
            insert_file_stream_length=insert_file_stream_length,
            insert_file_stream_position=insert_file_stream_position,
            insert_file_stream_read_timeout=insert_file_stream_read_timeout,
            insert_file_stream_write_timeout=insert_file_stream_write_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def insert_file_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID for inserting a file.")],
        insert_file_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The file to be inserted.")] = None,
        insert_file_title: Annotated[Optional[StrictStr], Field(description="The file title to be inserted.")] = None,
        insert_file_create_new_if_exist: Annotated[Optional[StrictBool], Field(description="Specifies whether to create a new file if it already exists or not.")] = None,
        insert_file_keep_convert_status: Annotated[Optional[StrictBool], Field(description="Specifies whether to keep the file converting status or not.")] = None,
        insert_file_stream_can_read: Optional[StrictBool] = None,
        insert_file_stream_can_write: Optional[StrictBool] = None,
        insert_file_stream_can_seek: Optional[StrictBool] = None,
        insert_file_stream_can_timeout: Optional[StrictBool] = None,
        insert_file_stream_length: Optional[StrictInt] = None,
        insert_file_stream_position: Optional[StrictInt] = None,
        insert_file_stream_read_timeout: Optional[StrictInt] = None,
        insert_file_stream_write_timeout: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileIntegerWrapper]:
        """Insert a file

        Inserts a file specified in the request to the selected folder by single file uploading.

        :param folder_id: The folder ID for inserting a file. (required)
        :type folder_id: int
        :param insert_file_file: The file to be inserted.
        :type insert_file_file: bytearray
        :param insert_file_title: The file title to be inserted.
        :type insert_file_title: str
        :param insert_file_create_new_if_exist: Specifies whether to create a new file if it already exists or not.
        :type insert_file_create_new_if_exist: bool
        :param insert_file_keep_convert_status: Specifies whether to keep the file converting status or not.
        :type insert_file_keep_convert_status: bool
        :param insert_file_stream_can_read:
        :type insert_file_stream_can_read: bool
        :param insert_file_stream_can_write:
        :type insert_file_stream_can_write: bool
        :param insert_file_stream_can_seek:
        :type insert_file_stream_can_seek: bool
        :param insert_file_stream_can_timeout:
        :type insert_file_stream_can_timeout: bool
        :param insert_file_stream_length:
        :type insert_file_stream_length: int
        :param insert_file_stream_position:
        :type insert_file_stream_position: int
        :param insert_file_stream_read_timeout:
        :type insert_file_stream_read_timeout: int
        :param insert_file_stream_write_timeout:
        :type insert_file_stream_write_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._insert_file_serialize(
            folder_id=folder_id,
            insert_file_file=insert_file_file,
            insert_file_title=insert_file_title,
            insert_file_create_new_if_exist=insert_file_create_new_if_exist,
            insert_file_keep_convert_status=insert_file_keep_convert_status,
            insert_file_stream_can_read=insert_file_stream_can_read,
            insert_file_stream_can_write=insert_file_stream_can_write,
            insert_file_stream_can_seek=insert_file_stream_can_seek,
            insert_file_stream_can_timeout=insert_file_stream_can_timeout,
            insert_file_stream_length=insert_file_stream_length,
            insert_file_stream_position=insert_file_stream_position,
            insert_file_stream_read_timeout=insert_file_stream_read_timeout,
            insert_file_stream_write_timeout=insert_file_stream_write_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def insert_file_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID for inserting a file.")],
        insert_file_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The file to be inserted.")] = None,
        insert_file_title: Annotated[Optional[StrictStr], Field(description="The file title to be inserted.")] = None,
        insert_file_create_new_if_exist: Annotated[Optional[StrictBool], Field(description="Specifies whether to create a new file if it already exists or not.")] = None,
        insert_file_keep_convert_status: Annotated[Optional[StrictBool], Field(description="Specifies whether to keep the file converting status or not.")] = None,
        insert_file_stream_can_read: Optional[StrictBool] = None,
        insert_file_stream_can_write: Optional[StrictBool] = None,
        insert_file_stream_can_seek: Optional[StrictBool] = None,
        insert_file_stream_can_timeout: Optional[StrictBool] = None,
        insert_file_stream_length: Optional[StrictInt] = None,
        insert_file_stream_position: Optional[StrictInt] = None,
        insert_file_stream_read_timeout: Optional[StrictInt] = None,
        insert_file_stream_write_timeout: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Insert a file

        Inserts a file specified in the request to the selected folder by single file uploading.

        :param folder_id: The folder ID for inserting a file. (required)
        :type folder_id: int
        :param insert_file_file: The file to be inserted.
        :type insert_file_file: bytearray
        :param insert_file_title: The file title to be inserted.
        :type insert_file_title: str
        :param insert_file_create_new_if_exist: Specifies whether to create a new file if it already exists or not.
        :type insert_file_create_new_if_exist: bool
        :param insert_file_keep_convert_status: Specifies whether to keep the file converting status or not.
        :type insert_file_keep_convert_status: bool
        :param insert_file_stream_can_read:
        :type insert_file_stream_can_read: bool
        :param insert_file_stream_can_write:
        :type insert_file_stream_can_write: bool
        :param insert_file_stream_can_seek:
        :type insert_file_stream_can_seek: bool
        :param insert_file_stream_can_timeout:
        :type insert_file_stream_can_timeout: bool
        :param insert_file_stream_length:
        :type insert_file_stream_length: int
        :param insert_file_stream_position:
        :type insert_file_stream_position: int
        :param insert_file_stream_read_timeout:
        :type insert_file_stream_read_timeout: int
        :param insert_file_stream_write_timeout:
        :type insert_file_stream_write_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._insert_file_serialize(
            folder_id=folder_id,
            insert_file_file=insert_file_file,
            insert_file_title=insert_file_title,
            insert_file_create_new_if_exist=insert_file_create_new_if_exist,
            insert_file_keep_convert_status=insert_file_keep_convert_status,
            insert_file_stream_can_read=insert_file_stream_can_read,
            insert_file_stream_can_write=insert_file_stream_can_write,
            insert_file_stream_can_seek=insert_file_stream_can_seek,
            insert_file_stream_can_timeout=insert_file_stream_can_timeout,
            insert_file_stream_length=insert_file_stream_length,
            insert_file_stream_position=insert_file_stream_position,
            insert_file_stream_read_timeout=insert_file_stream_read_timeout,
            insert_file_stream_write_timeout=insert_file_stream_write_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _insert_file_serialize(
        self,
        folder_id,
        insert_file_file,
        insert_file_title,
        insert_file_create_new_if_exist,
        insert_file_keep_convert_status,
        insert_file_stream_can_read,
        insert_file_stream_can_write,
        insert_file_stream_can_seek,
        insert_file_stream_can_timeout,
        insert_file_stream_length,
        insert_file_stream_position,
        insert_file_stream_read_timeout,
        insert_file_stream_write_timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if insert_file_file is not None:
            _files['InsertFile.File'] = insert_file_file
        if insert_file_title is not None:
            _form_params.append(('InsertFile.Title', insert_file_title))
        if insert_file_create_new_if_exist is not None:
            _form_params.append(('InsertFile.CreateNewIfExist', insert_file_create_new_if_exist))
        if insert_file_keep_convert_status is not None:
            _form_params.append(('InsertFile.KeepConvertStatus', insert_file_keep_convert_status))
        if insert_file_stream_can_read is not None:
            _form_params.append(('InsertFile.Stream.CanRead', insert_file_stream_can_read))
        if insert_file_stream_can_write is not None:
            _form_params.append(('InsertFile.Stream.CanWrite', insert_file_stream_can_write))
        if insert_file_stream_can_seek is not None:
            _form_params.append(('InsertFile.Stream.CanSeek', insert_file_stream_can_seek))
        if insert_file_stream_can_timeout is not None:
            _form_params.append(('InsertFile.Stream.CanTimeout', insert_file_stream_can_timeout))
        if insert_file_stream_length is not None:
            _form_params.append(('InsertFile.Stream.Length', insert_file_stream_length))
        if insert_file_stream_position is not None:
            _form_params.append(('InsertFile.Stream.Position', insert_file_stream_position))
        if insert_file_stream_read_timeout is not None:
            _form_params.append(('InsertFile.Stream.ReadTimeout', insert_file_stream_read_timeout))
        if insert_file_stream_write_timeout is not None:
            _form_params.append(('InsertFile.Stream.WriteTimeout', insert_file_stream_write_timeout))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.0/files/{folderId}/insert',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def insert_file_to_my_from_body(
        self,
        file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The file to be inserted.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The file title to be inserted.")] = None,
        create_new_if_exist: Annotated[Optional[StrictBool], Field(description="Specifies whether to create a new file if it already exists or not.")] = None,
        keep_convert_status: Annotated[Optional[StrictBool], Field(description="Specifies whether to keep the file converting status or not.")] = None,
        stream_can_read: Optional[StrictBool] = None,
        stream_can_write: Optional[StrictBool] = None,
        stream_can_seek: Optional[StrictBool] = None,
        stream_can_timeout: Optional[StrictBool] = None,
        stream_length: Optional[StrictInt] = None,
        stream_position: Optional[StrictInt] = None,
        stream_read_timeout: Optional[StrictInt] = None,
        stream_write_timeout: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileIntegerWrapper:
        """Insert a file to the \"My documents\" section

        Inserts a file specified in the request to the \"My documents\" section by single file uploading.

        :param file: The file to be inserted.
        :type file: bytearray
        :param title: The file title to be inserted.
        :type title: str
        :param create_new_if_exist: Specifies whether to create a new file if it already exists or not.
        :type create_new_if_exist: bool
        :param keep_convert_status: Specifies whether to keep the file converting status or not.
        :type keep_convert_status: bool
        :param stream_can_read:
        :type stream_can_read: bool
        :param stream_can_write:
        :type stream_can_write: bool
        :param stream_can_seek:
        :type stream_can_seek: bool
        :param stream_can_timeout:
        :type stream_can_timeout: bool
        :param stream_length:
        :type stream_length: int
        :param stream_position:
        :type stream_position: int
        :param stream_read_timeout:
        :type stream_read_timeout: int
        :param stream_write_timeout:
        :type stream_write_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._insert_file_to_my_from_body_serialize(
            file=file,
            title=title,
            create_new_if_exist=create_new_if_exist,
            keep_convert_status=keep_convert_status,
            stream_can_read=stream_can_read,
            stream_can_write=stream_can_write,
            stream_can_seek=stream_can_seek,
            stream_can_timeout=stream_can_timeout,
            stream_length=stream_length,
            stream_position=stream_position,
            stream_read_timeout=stream_read_timeout,
            stream_write_timeout=stream_write_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def insert_file_to_my_from_body_with_http_info(
        self,
        file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The file to be inserted.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The file title to be inserted.")] = None,
        create_new_if_exist: Annotated[Optional[StrictBool], Field(description="Specifies whether to create a new file if it already exists or not.")] = None,
        keep_convert_status: Annotated[Optional[StrictBool], Field(description="Specifies whether to keep the file converting status or not.")] = None,
        stream_can_read: Optional[StrictBool] = None,
        stream_can_write: Optional[StrictBool] = None,
        stream_can_seek: Optional[StrictBool] = None,
        stream_can_timeout: Optional[StrictBool] = None,
        stream_length: Optional[StrictInt] = None,
        stream_position: Optional[StrictInt] = None,
        stream_read_timeout: Optional[StrictInt] = None,
        stream_write_timeout: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileIntegerWrapper]:
        """Insert a file to the \"My documents\" section

        Inserts a file specified in the request to the \"My documents\" section by single file uploading.

        :param file: The file to be inserted.
        :type file: bytearray
        :param title: The file title to be inserted.
        :type title: str
        :param create_new_if_exist: Specifies whether to create a new file if it already exists or not.
        :type create_new_if_exist: bool
        :param keep_convert_status: Specifies whether to keep the file converting status or not.
        :type keep_convert_status: bool
        :param stream_can_read:
        :type stream_can_read: bool
        :param stream_can_write:
        :type stream_can_write: bool
        :param stream_can_seek:
        :type stream_can_seek: bool
        :param stream_can_timeout:
        :type stream_can_timeout: bool
        :param stream_length:
        :type stream_length: int
        :param stream_position:
        :type stream_position: int
        :param stream_read_timeout:
        :type stream_read_timeout: int
        :param stream_write_timeout:
        :type stream_write_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._insert_file_to_my_from_body_serialize(
            file=file,
            title=title,
            create_new_if_exist=create_new_if_exist,
            keep_convert_status=keep_convert_status,
            stream_can_read=stream_can_read,
            stream_can_write=stream_can_write,
            stream_can_seek=stream_can_seek,
            stream_can_timeout=stream_can_timeout,
            stream_length=stream_length,
            stream_position=stream_position,
            stream_read_timeout=stream_read_timeout,
            stream_write_timeout=stream_write_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def insert_file_to_my_from_body_without_preload_content(
        self,
        file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The file to be inserted.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The file title to be inserted.")] = None,
        create_new_if_exist: Annotated[Optional[StrictBool], Field(description="Specifies whether to create a new file if it already exists or not.")] = None,
        keep_convert_status: Annotated[Optional[StrictBool], Field(description="Specifies whether to keep the file converting status or not.")] = None,
        stream_can_read: Optional[StrictBool] = None,
        stream_can_write: Optional[StrictBool] = None,
        stream_can_seek: Optional[StrictBool] = None,
        stream_can_timeout: Optional[StrictBool] = None,
        stream_length: Optional[StrictInt] = None,
        stream_position: Optional[StrictInt] = None,
        stream_read_timeout: Optional[StrictInt] = None,
        stream_write_timeout: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Insert a file to the \"My documents\" section

        Inserts a file specified in the request to the \"My documents\" section by single file uploading.

        :param file: The file to be inserted.
        :type file: bytearray
        :param title: The file title to be inserted.
        :type title: str
        :param create_new_if_exist: Specifies whether to create a new file if it already exists or not.
        :type create_new_if_exist: bool
        :param keep_convert_status: Specifies whether to keep the file converting status or not.
        :type keep_convert_status: bool
        :param stream_can_read:
        :type stream_can_read: bool
        :param stream_can_write:
        :type stream_can_write: bool
        :param stream_can_seek:
        :type stream_can_seek: bool
        :param stream_can_timeout:
        :type stream_can_timeout: bool
        :param stream_length:
        :type stream_length: int
        :param stream_position:
        :type stream_position: int
        :param stream_read_timeout:
        :type stream_read_timeout: int
        :param stream_write_timeout:
        :type stream_write_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._insert_file_to_my_from_body_serialize(
            file=file,
            title=title,
            create_new_if_exist=create_new_if_exist,
            keep_convert_status=keep_convert_status,
            stream_can_read=stream_can_read,
            stream_can_write=stream_can_write,
            stream_can_seek=stream_can_seek,
            stream_can_timeout=stream_can_timeout,
            stream_length=stream_length,
            stream_position=stream_position,
            stream_read_timeout=stream_read_timeout,
            stream_write_timeout=stream_write_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileIntegerWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _insert_file_to_my_from_body_serialize(
        self,
        file,
        title,
        create_new_if_exist,
        keep_convert_status,
        stream_can_read,
        stream_can_write,
        stream_can_seek,
        stream_can_timeout,
        stream_length,
        stream_position,
        stream_read_timeout,
        stream_write_timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if file is not None:
            _files['File'] = file
        if title is not None:
            _form_params.append(('Title', title))
        if create_new_if_exist is not None:
            _form_params.append(('CreateNewIfExist', create_new_if_exist))
        if keep_convert_status is not None:
            _form_params.append(('KeepConvertStatus', keep_convert_status))
        if stream_can_read is not None:
            _form_params.append(('Stream.CanRead', stream_can_read))
        if stream_can_write is not None:
            _form_params.append(('Stream.CanWrite', stream_can_write))
        if stream_can_seek is not None:
            _form_params.append(('Stream.CanSeek', stream_can_seek))
        if stream_can_timeout is not None:
            _form_params.append(('Stream.CanTimeout', stream_can_timeout))
        if stream_length is not None:
            _form_params.append(('Stream.Length', stream_length))
        if stream_position is not None:
            _form_params.append(('Stream.Position', stream_position))
        if stream_read_timeout is not None:
            _form_params.append(('Stream.ReadTimeout', stream_read_timeout))
        if stream_write_timeout is not None:
            _form_params.append(('Stream.WriteTimeout', stream_write_timeout))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.0/files/@my/insert',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def rename_folder(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID for the folder creation.")],
        create_folder: Annotated[Optional[CreateFolder], Field(description="The parameters for creating a folder.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FolderIntegerWrapper:
        """Rename a folder

        Renames the selected folder with a new title specified in the request.

        :param folder_id: The folder ID for the folder creation. (required)
        :type folder_id: int
        :param create_folder: The parameters for creating a folder.
        :type create_folder: CreateFolder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rename_folder_serialize(
            folder_id=folder_id,
            create_folder=create_folder,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def rename_folder_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID for the folder creation.")],
        create_folder: Annotated[Optional[CreateFolder], Field(description="The parameters for creating a folder.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FolderIntegerWrapper]:
        """Rename a folder

        Renames the selected folder with a new title specified in the request.

        :param folder_id: The folder ID for the folder creation. (required)
        :type folder_id: int
        :param create_folder: The parameters for creating a folder.
        :type create_folder: CreateFolder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rename_folder_serialize(
            folder_id=folder_id,
            create_folder=create_folder,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def rename_folder_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID for the folder creation.")],
        create_folder: Annotated[Optional[CreateFolder], Field(description="The parameters for creating a folder.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Rename a folder

        Renames the selected folder with a new title specified in the request.

        :param folder_id: The folder ID for the folder creation. (required)
        :type folder_id: int
        :param create_folder: The parameters for creating a folder.
        :type create_folder: CreateFolder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rename_folder_serialize(
            folder_id=folder_id,
            create_folder=create_folder,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _rename_folder_serialize(
        self,
        folder_id,
        create_folder,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_folder is not None:
            _body_params = create_folder


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/2.0/files/folder/{folderId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def set_folder_order(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder unique identifier.")],
        order_request_dto: Annotated[Optional[OrderRequestDto], Field(description="The folder order information.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FolderIntegerWrapper:
        """Set folder order

        Sets the file order in the folder with ID specified in the request.

        :param folder_id: The folder unique identifier. (required)
        :type folder_id: int
        :param order_request_dto: The folder order information.
        :type order_request_dto: OrderRequestDto
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_folder_order_serialize(
            folder_id=folder_id,
            order_request_dto=order_request_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_folder_order_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder unique identifier.")],
        order_request_dto: Annotated[Optional[OrderRequestDto], Field(description="The folder order information.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FolderIntegerWrapper]:
        """Set folder order

        Sets the file order in the folder with ID specified in the request.

        :param folder_id: The folder unique identifier. (required)
        :type folder_id: int
        :param order_request_dto: The folder order information.
        :type order_request_dto: OrderRequestDto
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_folder_order_serialize(
            folder_id=folder_id,
            order_request_dto=order_request_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def set_folder_order_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder unique identifier.")],
        order_request_dto: Annotated[Optional[OrderRequestDto], Field(description="The folder order information.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Set folder order

        Sets the file order in the folder with ID specified in the request.

        :param folder_id: The folder unique identifier. (required)
        :type folder_id: int
        :param order_request_dto: The folder order information.
        :type order_request_dto: OrderRequestDto
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_folder_order_serialize(
            folder_id=folder_id,
            order_request_dto=order_request_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FolderIntegerWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _set_folder_order_serialize(
        self,
        folder_id,
        order_request_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if order_request_dto is not None:
            _body_params = order_request_dto


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/2.0/files/folder/{folderId}/order',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def upload_file(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID to upload a file.")],
        upload_request_dto: Annotated[Optional[UploadRequestDto], Field(description="The request parameters for uploading a file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectWrapper:
        """Upload a file

        Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>

        :param folder_id: The folder ID to upload a file. (required)
        :type folder_id: int
        :param upload_request_dto: The request parameters for uploading a file.
        :type upload_request_dto: UploadRequestDto
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_file_serialize(
            folder_id=folder_id,
            upload_request_dto=upload_request_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def upload_file_with_http_info(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID to upload a file.")],
        upload_request_dto: Annotated[Optional[UploadRequestDto], Field(description="The request parameters for uploading a file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectWrapper]:
        """Upload a file

        Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>

        :param folder_id: The folder ID to upload a file. (required)
        :type folder_id: int
        :param upload_request_dto: The request parameters for uploading a file.
        :type upload_request_dto: UploadRequestDto
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_file_serialize(
            folder_id=folder_id,
            upload_request_dto=upload_request_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def upload_file_without_preload_content(
        self,
        folder_id: Annotated[StrictInt, Field(description="The folder ID to upload a file.")],
        upload_request_dto: Annotated[Optional[UploadRequestDto], Field(description="The request parameters for uploading a file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Upload a file

        Uploads a file specified in the request to the selected folder by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>

        :param folder_id: The folder ID to upload a file. (required)
        :type folder_id: int
        :param upload_request_dto: The request parameters for uploading a file.
        :type upload_request_dto: UploadRequestDto
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_file_serialize(
            folder_id=folder_id,
            upload_request_dto=upload_request_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _upload_file_serialize(
        self,
        folder_id,
        upload_request_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if folder_id is not None:
            _path_params['folderId'] = folder_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if upload_request_dto is not None:
            _body_params = upload_request_dto


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.0/files/{folderId}/upload',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def upload_file_to_my(
        self,
        in_dto: Annotated[Optional[UploadRequestDto], Field(description="The request parameters for uploading a file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectWrapper:
        """Upload a file to the \"My documents\" section

        Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>

        :param in_dto: The request parameters for uploading a file.
        :type in_dto: UploadRequestDto
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_file_to_my_serialize(
            in_dto=in_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def upload_file_to_my_with_http_info(
        self,
        in_dto: Annotated[Optional[UploadRequestDto], Field(description="The request parameters for uploading a file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectWrapper]:
        """Upload a file to the \"My documents\" section

        Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>

        :param in_dto: The request parameters for uploading a file.
        :type in_dto: UploadRequestDto
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_file_to_my_serialize(
            in_dto=in_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def upload_file_to_my_without_preload_content(
        self,
        in_dto: Annotated[Optional[UploadRequestDto], Field(description="The request parameters for uploading a file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Upload a file to the \"My documents\" section

        Uploads a file specified in the request to the \"My documents\" section by single file uploading or standart multipart/form-data method.   **Note**:  You can upload files in two different ways:   <ol>  <li>Using single file upload. You should set the Content-Type and Content-Disposition headers to specify a file name and content type, and send the file to the request body.</li>  <li>Using standart multipart/form-data method.</li>  </ol>

        :param in_dto: The request parameters for uploading a file.
        :type in_dto: UploadRequestDto
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_file_to_my_serialize(
            in_dto=in_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectWrapper",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _upload_file_to_my_serialize(
        self,
        in_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if in_dto is not None:
            
            _query_params.append(('inDto', in_dto))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Basic', 
            'OAuth2', 
            'ApiKeyBearer', 
            'asc_auth_key', 
            'Bearer', 
            'OpenId'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.0/files/@my/upload',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


