# coding: utf-8

"""
    ASC.Web.Api

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from docspace.models.account_login_type import AccountLoginType
from docspace.models.area import Area
from docspace.models.employee_activation_status import EmployeeActivationStatus
from docspace.models.employee_array_wrapper import EmployeeArrayWrapper
from docspace.models.employee_full_array_wrapper import EmployeeFullArrayWrapper
from docspace.models.employee_status import EmployeeStatus
from docspace.models.employee_type import EmployeeType
from docspace.models.object_array_wrapper import ObjectArrayWrapper
from docspace.models.payments import Payments
from docspace.models.quota_filter import QuotaFilter

from docspace.api_client import ApiClient, RequestSerialized
from docspace.api_response import ApiResponse
from docspace.rest import RESTResponseType


class PeopleSearchApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_accounts_entries_with_shared(
        self,
        id: Annotated[StrictInt, Field(description="ID")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="Employee status")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Exclude shared")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="Employee Types")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectArrayWrapper:
        """Gets accounts entries with shared

        Gets accounts entries with shared

        :param id: ID (required)
        :type id: int
        :param employee_status: Employee status
        :type employee_status: EmployeeStatus
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Exclude shared
        :type exclude_shared: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param employee_types: Employee Types
        :type employee_types: List[EmployeeType]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_accounts_entries_with_shared_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="ID")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="Employee status")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Exclude shared")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="Employee Types")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectArrayWrapper]:
        """Gets accounts entries with shared

        Gets accounts entries with shared

        :param id: ID (required)
        :type id: int
        :param employee_status: Employee status
        :type employee_status: EmployeeStatus
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Exclude shared
        :type exclude_shared: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param employee_types: Employee Types
        :type employee_types: List[EmployeeType]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_accounts_entries_with_shared_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="ID")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="Employee status")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Exclude shared")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="Employee Types")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets accounts entries with shared

        Gets accounts entries with shared

        :param id: ID (required)
        :type id: int
        :param employee_status: Employee status
        :type employee_status: EmployeeStatus
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Exclude shared
        :type exclude_shared: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param employee_types: Employee Types
        :type employee_types: List[EmployeeType]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_accounts_entries_with_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_accounts_entries_with_shared_serialize(
        self,
        id,
        employee_status,
        activation_status,
        exclude_shared,
        invited_by_me,
        inviter_id,
        area,
        employee_types,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if exclude_shared is not None:
            
            _query_params.append(('excludeShared', exclude_shared))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'asc_auth_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/accounts/room/{id}/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_advanced(
        self,
        status: Annotated[EmployeeStatus, Field(description="User status")],
        query: Annotated[Optional[StrictStr], Field(description="Search query")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Search users by status filter

        Returns a list of users matching the status filter and search query.

        :param status: User status (required)
        :type status: EmployeeStatus
        :param query: Search query
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_advanced_serialize(
            status=status,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_advanced_with_http_info(
        self,
        status: Annotated[EmployeeStatus, Field(description="User status")],
        query: Annotated[Optional[StrictStr], Field(description="Search query")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Search users by status filter

        Returns a list of users matching the status filter and search query.

        :param status: User status (required)
        :type status: EmployeeStatus
        :param query: Search query
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_advanced_serialize(
            status=status,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_advanced_without_preload_content(
        self,
        status: Annotated[EmployeeStatus, Field(description="User status")],
        query: Annotated[Optional[StrictStr], Field(description="Search query")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users by status filter

        Returns a list of users matching the status filter and search query.

        :param status: User status (required)
        :type status: EmployeeStatus
        :param query: Search query
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_advanced_serialize(
            status=status,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_advanced_serialize(
        self,
        status,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if status is not None:
            _path_params['status'] = status.value
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'asc_auth_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/status/{status}/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_full_by_filter(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="User status")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="Group ID")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="User type")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="List of user types")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not")] = None,
        payments: Annotated[Optional[Payments], Field(description="User payment status")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="Account login type")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="Filter by quota (All - 0, Default - 1, Custom - 2)")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether or not the user should be a member of the group with the specified ID")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Search users and their information by extended filter

        Returns a list of users with full information about them matching the parameters specified in the request.

        :param employee_status: User status
        :type employee_status: EmployeeStatus
        :param group_id: Group ID
        :type group_id: str
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param employee_type: User type
        :type employee_type: EmployeeType
        :param employee_types: List of user types
        :type employee_types: List[EmployeeType]
        :param is_administrator: Specifies if the user is an administrator or not
        :type is_administrator: bool
        :param payments: User payment status
        :type payments: Payments
        :param account_login_type: Account login type
        :type account_login_type: AccountLoginType
        :param quota_filter: Filter by quota (All - 0, Default - 1, Custom - 2)
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not
        :type without_group: bool
        :param exclude_group: Specifies whether or not the user should be a member of the group with the specified ID
        :type exclude_group: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_full_by_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_full_by_filter_with_http_info(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="User status")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="Group ID")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="User type")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="List of user types")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not")] = None,
        payments: Annotated[Optional[Payments], Field(description="User payment status")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="Account login type")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="Filter by quota (All - 0, Default - 1, Custom - 2)")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether or not the user should be a member of the group with the specified ID")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Search users and their information by extended filter

        Returns a list of users with full information about them matching the parameters specified in the request.

        :param employee_status: User status
        :type employee_status: EmployeeStatus
        :param group_id: Group ID
        :type group_id: str
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param employee_type: User type
        :type employee_type: EmployeeType
        :param employee_types: List of user types
        :type employee_types: List[EmployeeType]
        :param is_administrator: Specifies if the user is an administrator or not
        :type is_administrator: bool
        :param payments: User payment status
        :type payments: Payments
        :param account_login_type: Account login type
        :type account_login_type: AccountLoginType
        :param quota_filter: Filter by quota (All - 0, Default - 1, Custom - 2)
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not
        :type without_group: bool
        :param exclude_group: Specifies whether or not the user should be a member of the group with the specified ID
        :type exclude_group: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_full_by_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_full_by_filter_without_preload_content(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="User status")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="Group ID")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="User type")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="List of user types")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not")] = None,
        payments: Annotated[Optional[Payments], Field(description="User payment status")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="Account login type")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="Filter by quota (All - 0, Default - 1, Custom - 2)")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether or not the user should be a member of the group with the specified ID")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users and their information by extended filter

        Returns a list of users with full information about them matching the parameters specified in the request.

        :param employee_status: User status
        :type employee_status: EmployeeStatus
        :param group_id: Group ID
        :type group_id: str
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param employee_type: User type
        :type employee_type: EmployeeType
        :param employee_types: List of user types
        :type employee_types: List[EmployeeType]
        :param is_administrator: Specifies if the user is an administrator or not
        :type is_administrator: bool
        :param payments: User payment status
        :type payments: Payments
        :param account_login_type: Account login type
        :type account_login_type: AccountLoginType
        :param quota_filter: Filter by quota (All - 0, Default - 1, Custom - 2)
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not
        :type without_group: bool
        :param exclude_group: Specifies whether or not the user should be a member of the group with the specified ID
        :type exclude_group: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_full_by_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_full_by_filter_serialize(
        self,
        employee_status,
        group_id,
        activation_status,
        employee_type,
        employee_types,
        is_administrator,
        payments,
        account_login_type,
        quota_filter,
        without_group,
        exclude_group,
        invited_by_me,
        inviter_id,
        area,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if employee_type is not None:
            
            _query_params.append(('employeeType', employee_type.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if is_administrator is not None:
            
            _query_params.append(('isAdministrator', is_administrator))
            
        if payments is not None:
            
            _query_params.append(('payments', payments.value))
            
        if account_login_type is not None:
            
            _query_params.append(('accountLoginType', account_login_type.value))
            
        if quota_filter is not None:
            
            _query_params.append(('quotaFilter', quota_filter.value))
            
        if without_group is not None:
            
            _query_params.append(('withoutGroup', without_group))
            
        if exclude_group is not None:
            
            _query_params.append(('excludeGroup', exclude_group))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'asc_auth_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/filter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_people_search(
        self,
        query: Annotated[Optional[StrictStr], Field(description="Search query")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeArrayWrapper:
        """Search users (using query parameters)

        Returns a list of users matching the search query. This method uses the query parameters.

        :param query: Search query
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_people_search_serialize(
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_people_search_with_http_info(
        self,
        query: Annotated[Optional[StrictStr], Field(description="Search query")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeArrayWrapper]:
        """Search users (using query parameters)

        Returns a list of users matching the search query. This method uses the query parameters.

        :param query: Search query
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_people_search_serialize(
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_people_search_without_preload_content(
        self,
        query: Annotated[Optional[StrictStr], Field(description="Search query")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users (using query parameters)

        Returns a list of users matching the search query. This method uses the query parameters.

        :param query: Search query
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_people_search_serialize(
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_people_search_serialize(
        self,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'asc_auth_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_search(
        self,
        query: Annotated[StrictStr, Field(description="Search query")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Search users

        Returns a list of users matching the search query.

        :param query: Search query (required)
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_search_serialize(
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_search_with_http_info(
        self,
        query: Annotated[StrictStr, Field(description="Search query")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Search users

        Returns a list of users matching the search query.

        :param query: Search query (required)
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_search_serialize(
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_search_without_preload_content(
        self,
        query: Annotated[StrictStr, Field(description="Search query")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users

        Returns a list of users matching the search query.

        :param query: Search query (required)
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_search_serialize(
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_search_serialize(
        self,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if query is not None:
            _path_params['query'] = query
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'asc_auth_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/@search/{query}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_simple_by_filter(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="User status")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="Group ID")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="User type")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="List of user types")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not")] = None,
        payments: Annotated[Optional[Payments], Field(description="User payment status")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="Account login type")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="Filter by quota (All - 0, Default - 1, Custom - 2)")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether or not the user should be a member of the group with the specified ID")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeArrayWrapper:
        """Search users by extended filter

        Returns a list of users matching the parameters specified in the request.

        :param employee_status: User status
        :type employee_status: EmployeeStatus
        :param group_id: Group ID
        :type group_id: str
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param employee_type: User type
        :type employee_type: EmployeeType
        :param employee_types: List of user types
        :type employee_types: List[EmployeeType]
        :param is_administrator: Specifies if the user is an administrator or not
        :type is_administrator: bool
        :param payments: User payment status
        :type payments: Payments
        :param account_login_type: Account login type
        :type account_login_type: AccountLoginType
        :param quota_filter: Filter by quota (All - 0, Default - 1, Custom - 2)
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not
        :type without_group: bool
        :param exclude_group: Specifies whether or not the user should be a member of the group with the specified ID
        :type exclude_group: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_simple_by_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_simple_by_filter_with_http_info(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="User status")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="Group ID")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="User type")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="List of user types")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not")] = None,
        payments: Annotated[Optional[Payments], Field(description="User payment status")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="Account login type")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="Filter by quota (All - 0, Default - 1, Custom - 2)")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether or not the user should be a member of the group with the specified ID")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeArrayWrapper]:
        """Search users by extended filter

        Returns a list of users matching the parameters specified in the request.

        :param employee_status: User status
        :type employee_status: EmployeeStatus
        :param group_id: Group ID
        :type group_id: str
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param employee_type: User type
        :type employee_type: EmployeeType
        :param employee_types: List of user types
        :type employee_types: List[EmployeeType]
        :param is_administrator: Specifies if the user is an administrator or not
        :type is_administrator: bool
        :param payments: User payment status
        :type payments: Payments
        :param account_login_type: Account login type
        :type account_login_type: AccountLoginType
        :param quota_filter: Filter by quota (All - 0, Default - 1, Custom - 2)
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not
        :type without_group: bool
        :param exclude_group: Specifies whether or not the user should be a member of the group with the specified ID
        :type exclude_group: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_simple_by_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_simple_by_filter_without_preload_content(
        self,
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="User status")] = None,
        group_id: Annotated[Optional[StrictStr], Field(description="Group ID")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        employee_type: Annotated[Optional[EmployeeType], Field(description="User type")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="List of user types")] = None,
        is_administrator: Annotated[Optional[StrictBool], Field(description="Specifies if the user is an administrator or not")] = None,
        payments: Annotated[Optional[Payments], Field(description="User payment status")] = None,
        account_login_type: Annotated[Optional[AccountLoginType], Field(description="Account login type")] = None,
        quota_filter: Annotated[Optional[QuotaFilter], Field(description="Filter by quota (All - 0, Default - 1, Custom - 2)")] = None,
        without_group: Annotated[Optional[StrictBool], Field(description="Specifies whether the user should be a member of a group or not")] = None,
        exclude_group: Annotated[Optional[StrictBool], Field(description="Specifies whether or not the user should be a member of the group with the specified ID")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search users by extended filter

        Returns a list of users matching the parameters specified in the request.

        :param employee_status: User status
        :type employee_status: EmployeeStatus
        :param group_id: Group ID
        :type group_id: str
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param employee_type: User type
        :type employee_type: EmployeeType
        :param employee_types: List of user types
        :type employee_types: List[EmployeeType]
        :param is_administrator: Specifies if the user is an administrator or not
        :type is_administrator: bool
        :param payments: User payment status
        :type payments: Payments
        :param account_login_type: Account login type
        :type account_login_type: AccountLoginType
        :param quota_filter: Filter by quota (All - 0, Default - 1, Custom - 2)
        :type quota_filter: QuotaFilter
        :param without_group: Specifies whether the user should be a member of a group or not
        :type without_group: bool
        :param exclude_group: Specifies whether or not the user should be a member of the group with the specified ID
        :type exclude_group: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_simple_by_filter_serialize(
            employee_status=employee_status,
            group_id=group_id,
            activation_status=activation_status,
            employee_type=employee_type,
            employee_types=employee_types,
            is_administrator=is_administrator,
            payments=payments,
            account_login_type=account_login_type,
            quota_filter=quota_filter,
            without_group=without_group,
            exclude_group=exclude_group,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_simple_by_filter_serialize(
        self,
        employee_status,
        group_id,
        activation_status,
        employee_type,
        employee_types,
        is_administrator,
        payments,
        account_login_type,
        quota_filter,
        without_group,
        exclude_group,
        invited_by_me,
        inviter_id,
        area,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if employee_type is not None:
            
            _query_params.append(('employeeType', employee_type.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        if is_administrator is not None:
            
            _query_params.append(('isAdministrator', is_administrator))
            
        if payments is not None:
            
            _query_params.append(('payments', payments.value))
            
        if account_login_type is not None:
            
            _query_params.append(('accountLoginType', account_login_type.value))
            
        if quota_filter is not None:
            
            _query_params.append(('quotaFilter', quota_filter.value))
            
        if without_group is not None:
            
            _query_params.append(('withoutGroup', without_group))
            
        if exclude_group is not None:
            
            _query_params.append(('excludeGroup', exclude_group))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'asc_auth_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/simple/filter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_users_with_room_shared(
        self,
        id: Annotated[StrictInt, Field(description="Id")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="Employee status")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Exclude shared")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="Employee Types")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EmployeeFullArrayWrapper:
        """Gets users with shared in room ID specified in request

        Gets users with shared in room ID specified in request

        :param id: Id (required)
        :type id: int
        :param employee_status: Employee status
        :type employee_status: EmployeeStatus
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Exclude shared
        :type exclude_shared: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param employee_types: Employee Types
        :type employee_types: List[EmployeeType]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_room_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_users_with_room_shared_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Id")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="Employee status")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Exclude shared")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="Employee Types")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EmployeeFullArrayWrapper]:
        """Gets users with shared in room ID specified in request

        Gets users with shared in room ID specified in request

        :param id: Id (required)
        :type id: int
        :param employee_status: Employee status
        :type employee_status: EmployeeStatus
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Exclude shared
        :type exclude_shared: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param employee_types: Employee Types
        :type employee_types: List[EmployeeType]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_room_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_users_with_room_shared_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Id")],
        employee_status: Annotated[Optional[EmployeeStatus], Field(description="Employee status")] = None,
        activation_status: Annotated[Optional[EmployeeActivationStatus], Field(description="Activation status")] = None,
        exclude_shared: Annotated[Optional[StrictBool], Field(description="Exclude shared")] = None,
        invited_by_me: Annotated[Optional[StrictBool], Field(description="Invited by me")] = None,
        inviter_id: Annotated[Optional[StrictStr], Field(description="Inviter Id")] = None,
        area: Annotated[Optional[Area], Field(description="Area")] = None,
        employee_types: Annotated[Optional[List[List[EmployeeType]]], Field(description="Employee Types")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets users with shared in room ID specified in request

        Gets users with shared in room ID specified in request

        :param id: Id (required)
        :type id: int
        :param employee_status: Employee status
        :type employee_status: EmployeeStatus
        :param activation_status: Activation status
        :type activation_status: EmployeeActivationStatus
        :param exclude_shared: Exclude shared
        :type exclude_shared: bool
        :param invited_by_me: Invited by me
        :type invited_by_me: bool
        :param inviter_id: Inviter Id
        :type inviter_id: str
        :param area: Area
        :type area: Area
        :param employee_types: Employee Types
        :type employee_types: List[EmployeeType]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_users_with_room_shared_serialize(
            id=id,
            employee_status=employee_status,
            activation_status=activation_status,
            exclude_shared=exclude_shared,
            invited_by_me=invited_by_me,
            inviter_id=inviter_id,
            area=area,
            employee_types=employee_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EmployeeFullArrayWrapper",
            '401': None,
            '403': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_users_with_room_shared_serialize(
        self,
        id,
        employee_status,
        activation_status,
        exclude_shared,
        invited_by_me,
        inviter_id,
        area,
        employee_types,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'employeeTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if employee_status is not None:
            
            _query_params.append(('employeeStatus', employee_status.value))
            
        if activation_status is not None:
            
            _query_params.append(('activationStatus', activation_status.value))
            
        if exclude_shared is not None:
            
            _query_params.append(('excludeShared', exclude_shared))
            
        if invited_by_me is not None:
            
            _query_params.append(('invitedByMe', invited_by_me))
            
        if inviter_id is not None:
            
            _query_params.append(('inviterId', inviter_id))
            
        if area is not None:
            
            _query_params.append(('area', area.value))
            
        if employee_types is not None:
            
            _query_params.append(('employeeTypes', employee_types))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'asc_auth_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.0/people/room/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


